{\rtf1\ansi\ansicpg936\cocoartf2578
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\vieww12000\viewh15160\viewkind0
\deftab720
\pard\pardeftab720\sl276\slmult1\sa200\partightenfactor0

\f0\fs22 \cf0 1. Hashing\
	- hashing is used to check exisitance of certain element\
	- hash map can be used to represent permutation and distinct elements\
2. Array\
	- Consider information needed from the array, it can be from 2 sides\
3. binary search\
	- search for an element in an ordered array\
	- search for viable solution in a range of answers\
	- search for max/min of valid answer\
	- munipulate conditions check for skewed sorted list\
	- Binary search can also be down with recursive function (More intuitive sometimes)\
	- The key in binary search is to use certain condition to get rid of a part of the search range every iteration, don't have to be half\
	- Use binary search to find kLargest/kSmallest (No order needed)\
4. Linked List\
	- Need to know reverse linked list\
	- Recursion (return node) (save space with out create a new list) and iteration (need extra space to create a new list)\
	- fast/slow pointers\
	- dictionary can take node/pointer as key (clone linked list)\
	- find entrance of the cycle (consider distance travelled by slow and fast pointers)\
	- think about double linked list (For LRU)\
	- heapq is not directly compatible to ListNode\
5. Heap/Priority Queue (priorityQueue is (key, val) heap)\
	- stream data attributes can have monotonic properties; Use heap to keep track of nLargest/nSmallest elements\
	- heapq is minheap, Use -key for maxheap\
	- task scheduler, heap & queue (store future timstamp in queue)\
	- heapq.nlargest(n, list: len of l) has time complextity O(n+(l-n) logn+nlogn) =  O(l logn) (first create a len n heap and then adding the rest elements with heappushpop (O(logn)) and sort the heap at the end (O(nlogn))\
	- heapq.nlargest do not need to heapify first\
	- useful for time\
	- use heap for maintain upper and lower structure\
6. Sort\
	- quickSelect for getting nLargest\
7. bit manipulation\
	- &, |, ^, ~, >>, <<\
	- XOR: ^, same number returns 0\
	- n & (n-1) flips the least significant 1-bit to 0-bit\
	- x>>1: x//2, x&1: x%2\
	- swap alternative bits n& 0xaaaaaaaa (all even bits) and n& 0x55555555 (all odd bits)\
	- bit mask is to find some mask such that n&mask returns the unmasked bit in n only\
Extra Bit\
	- Set Union A | B, set intersection A & B, set subtraction A&~B, set negative ~A\
	- Set i-th bit to 1, A|=1<<i; Clear i-th bit to 0, A &= ~(1<<i)\
	- Test i-th bit of A is 1, (A&1<<i) != 0\
	- extract last bit A&~A, A&~(A-1), A^(A&(A-1))\
	- remove last bit A&(A-1)\
	- get all 1-bits ~0\
8. Graph\
	- dfs, bfs\
	- Use recursion or stack/queue to run dfs/bfs\
	- like LinkedList Node, use hash map to store nodes (use for clone graph)\
	- use a hash to store grid position might be a good idea\
	- grid/matrix status can be represented by number\
	- sometimes, bfs can be in place to reduce space complexity\
	- Use collections.deque rather than list if possible, deque.popleft() is more efficient than list.pop(0)\
	- dfs may implement backtrack like addA...removeA\
	- Consider degree of vertices\
	- Disjoint sets for detecting cycle in undirected graph\
	- bidirectional bfs, seperately keep 2 pieces of queue and visited, check if the new state is in the other's visited\
9. Graph with weights\
	- MST, Kruskal's/Prim's (Kruskal's is relying on Union-Find)\
	- Dijkstra's Algorithm. Note the heap used is for candidate checking\
Graph related question: \
	- Topological sort, \
	- Union-Find, \
	- Eulerian path&Hierholzer's Algorithm, \
	- MST&Kruskal's Algorithm&Prim's Algorithm\
10. DP\
	- design states, we need to consider the sequence of the dependencies when we think about optimal structure; DP condition of later iterations should be dependent of early iterations\
	- 1D to cycle: states to consider\
		- convert to multiple 1D manually (seperate by choosing or deleting)\
	- palindrome: Let DP state be middle letter, check can be done In2Out or Out2In\
	- It is possible to track multiple dp tables potentially\
	- Only bottom-up dp can possibly have dimension reduction\
	- use bottom-up dp for count ways; Careful about permutation or combination ways\
	- consider about transition equation and also dependency list. Consider the order of dependency list\
11. String\
	- Add helper functions to make codes clear\
	- To see if a string is consisting of other strings, use dfs with i in range(len(str)) and check [:i] and [I:], also use memo\
12. Greedy\
	- To consider iteration piece by piece (We want to find some info which derived from previous info and enough for future decision)\
	- Consider what to do with cases that does not fit individual requirement, what is the info we need in the future?\
	- Consider Heap\
13. Interval\
	- When consider the relation between 2 intervals, consider the status of left and right boundaries\
	- To merge intervals, we want to sort intervals by ascending start and descending end\
	- Maybe think about the question solvable by greedy algorithm\
	- When count intersection, consider cumulative count of start and end\
14. Math\
	- Rotate matrix Inplace\
	- When do + or *, consider digit by digit\
15. Tree\
	- Consider a combination of pre-order, post-order traversal when needed, carry flag in recursion\
	- Think about the visiting order of different dfs traversal\
Trick in implementation:\
- Instead of globle/nonlocal variant, we can create a variable and pass into function without explicitly return it but just write on it\
- trick of using max(nums[n-1], nums[n-2]), if nums has length 1, this still works\
- recursion usually takes more memory\
- To store information, think about we need or we have\
- dictionary variable is a pointer\
	\
}